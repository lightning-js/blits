import path from 'path'
import * as fs from 'fs'
import { genFont, setGeneratePaths } from '@lightningjs/msdf-generator'
import { adjustFont } from '@lightningjs/msdf-generator/adjustFont'

// since font generation methods changed with the new renderer version,
// we need to clean up all the old font files generated by previous plugin implementation
// this is a temporary solution and should be removed in the future
let cleanupFinished = false
let filesToWarn = []
const dirsToCheck = [
  {
    dir: path.resolve('.', 'node_modules', '.tmp-msdf-fonts'),
    recursive: false,
    deleteFile: true,
  },
  {
    dir: path.resolve('.', 'public'),
    recursive: true,
    deleteFile: false,
  },
]

const deleteOldFontFiles = (dir, recursive, deleteFile = false) => {
  console.log(`Checking ${dir} for old font files...`)
  const files = fs.readdirSync(dir, { withFileTypes: true })

  files.forEach((file) => {
    if (file.isDirectory() && recursive) {
      deleteOldFontFiles(path.join(dir, file.name), recursive, deleteFile)
    } else {
      if (file.name.match(/\.json$/i)) {
        const jsonFile = path.join(dir, file.name)
        const jsonContent = JSON.parse(fs.readFileSync(jsonFile, 'utf8'))

        if (jsonContent.distanceField && jsonContent.kernings) {
          const pngFile = path.join(dir, file.name.replace(/\.json$/, '.png'))

          if (!jsonContent.lightningMetrics) {
            if (deleteFile) {
              console.log(`Deleting automatically generated old font file: ${jsonFile}`)
              console.log(`Deleting also the corresponding png file: ${pngFile}`)
              fs.unlinkSync(jsonFile)
              fs.unlinkSync(pngFile)
            } else {
              filesToWarn.push(jsonFile, pngFile)
            }
          }
        }
      }
    }
  })
}

const cleanup = () => {
  if (fs.existsSync(path.resolve('.', '.msdf-cleanup'))) {
    cleanupFinished = true
  }

  if (!cleanupFinished) {
    dirsToCheck.forEach((path) => {
      deleteOldFontFiles(path.dir, path.recursive, path.deleteFile)
    })

    if (filesToWarn.length > 0) {
      const fileList = filesToWarn.map((file) => `  - ${file}`).join('\n')
      const warningMessage = `
      Warning: Old msdf font files detected
      ----------------------------------
      Files:
      ${fileList}

      These files were generated by the old MSDF generator and should be deleted.

      Important:
      - All MSDF font files must be generated using the new @lightningjs/msdf-generator package.
      - If the files listed above are deleted, corresponding MSDF files will be automatically generated under the node_modules/.tmp-msdf-fonts folder and included in the build output.

      Please delete the old font files to ensure that font files can work properly with the new Lightning 3 renderer version.
      `
        .split('\n')
        .map((line) => (line.trim() ? `\x1b[33m${line.trim()}\x1b[0m` : ''))
        .join('\n')

      console.warn(warningMessage)
    }
    // create a file to indicate that cleanup has been done
    fs.writeFileSync(path.resolve('.', '.msdf-cleanup'), '')
    cleanupFinished = true
  }
}

class TaskQueue {
  constructor() {
    this.currentTask = Promise.resolve()
  }

  async enqueue(task) {
    // Wait for the current task to complete before starting a new one
    this.currentTask = this.currentTask.then(task, this.handleError)
    await this.currentTask
  }

  handleError(error) {
    console.error('Error during task execution:', error)
  }
}

const fontGenerationQueue = new TaskQueue()
let config

export default function () {
  let msdfOutputDir = ''
  let buildOutputPath = ''
  let publicDir = ''

  return {
    name: 'msdfGenerator',
    configResolved(resolvedConfig) {
      config = resolvedConfig
      buildOutputPath = config.build.outDir
      publicDir = path.join(config.root, 'public')
      msdfOutputDir = path.resolve(config.root, 'node_modules', '.tmp-msdf-fonts')
    },
    async configureServer(server) {
      server.middlewareMode = true
      server.middlewares.use('/', async (req, res, next) => {
        // temporary cleanup
        cleanup()

        const file = req.url.substring(req.url.lastIndexOf('/') + 1)
        const match = file.match(/(.+)\.msdf\.(json|png)/)
        // msdf font request
        if (match) {
          const fontPath = path.dirname(req.url.split('?')[0]).replace(/^\//, '')
          const fontDir = path.join(publicDir, fontPath) // actual font directory
          const targetDir = path.join(msdfOutputDir, fontPath) // target for generated fonts

          if (!fs.existsSync(path.resolve(fontDir, file))) {
            const fontName = match[1]
            const ext = match[2]
            const fontFile = path.join(fontDir, `${fontName}.ttf`)

            if (fs.existsSync(fontFile)) {
              const generatedFontFile = path.join(
                msdfOutputDir,
                fontPath,
                `${fontName}.msdf.${ext}`
              )
              const mimeType = ext === 'png' ? 'image/png' : 'application/json'

              await fontGenerationQueue.enqueue(async () => {
                if (!fs.existsSync(generatedFontFile)) {
                  // Check if generation is needed
                  console.log(`\nGenerating ${targetDir}/${fontName}.msdf.${ext}`)
                  await generateSDF(fontFile, path.join(targetDir))
                }
              })

              if (fs.existsSync(generatedFontFile)) {
                const fileContent = fs.readFileSync(generatedFontFile)

                // Check if headers have already been sent
                if (!res.headersSent) {
                  res.setHeader('Content-Type', mimeType)
                  res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')
                  res.end(fileContent)
                } else {
                  // this should never happen except some edge cases
                  console.error(`ERROR: Headers already sent for ${req.url}`, res.getHeaders())
                }
              } else {
                next() // Handle case where generation might have failed
              }
            } else {
              next() // ttf file does not exist
            }
          } else {
            next() // file exists
          }
        } else {
          next() // not msdf.json or msdf.png
        }
      })
    },
    // after build ends, the first hook is renderStart where we can modify the output
    async renderStart() {
      const ttfFiles = findAllTtfFiles(publicDir)

      for (const ttfFile of ttfFiles) {
        const relativePath = path.relative(publicDir, path.dirname(ttfFile))
        const baseName = path.basename(ttfFile).replace(/\.ttf$/i, '')
        const msdfJsonPath = path.join(msdfOutputDir, relativePath, `${baseName}.msdf.json`)
        const msdfPngPath = path.join(msdfOutputDir, relativePath, `${baseName}.msdf.png`)

        // Check if MSDF files are generated, if not, generate them
        if (!fs.existsSync(msdfJsonPath) || !fs.existsSync(msdfPngPath)) {
          console.log(`Generating missing MSDF files for ${ttfFile}`)
          await generateSDF(ttfFile, path.join(msdfOutputDir, relativePath))
        }
      }

      if (fs.existsSync(msdfOutputDir)) {
        copyDir(msdfOutputDir, buildOutputPath)
      }
    },
  }
}

const generateSDF = async (inputFilePath, outputDirPath) => {
  // Ensure the destination directory exists
  fs.mkdirSync(outputDirPath, { recursive: true })

  setGeneratePaths(path.dirname(inputFilePath), outputDirPath)

  let font = await genFont(path.basename(inputFilePath), 'msdf')

  if (font) await adjustFont(font)
  else console.error('Failed to generate MSDF file')
}

// finds all TTF files in a directory
const findAllTtfFiles = (dir, filesList = []) => {
  const files = fs.readdirSync(dir, { withFileTypes: true })

  files.forEach((file) => {
    if (file.isDirectory()) {
      const dirPath = path.join(dir, file.name)
      findAllTtfFiles(dirPath, filesList)
    } else {
      // Check for all case variations of TTF extension
      if (file.name.match(/\.ttf$/i)) {
        filesList.push(path.join(dir, file.name))
      }
    }
  })

  return filesList
}

const copyDir = (src, dest) => {
  // Ensure the destination directory exists
  fs.mkdirSync(dest, { recursive: true })

  const entries = fs.readdirSync(src, { withFileTypes: true })

  for (let entry of entries) {
    const srcPath = path.join(src, entry.name)
    const destPath = path.join(dest, entry.name)

    entry.isDirectory() ? copyDir(srcPath, destPath) : fs.copyFileSync(srcPath, destPath) // Copy files
  }
}
